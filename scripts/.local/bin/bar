#!/usr/bin/env python

from datetime import datetime
import subprocess
import argparse
import asyncio
import socket
import sys
import re


class BarString:
    # used for workspace display
    WS_NUMBER = 5

    def __init__(self):
        self.ws_list = [""] * self.WS_NUMBER

    # constants for analysing levels (eg. volume, battery etc)
    FULL = 95
    MID = 50
    LOW = 20

    # utility function to turn percent integer into fixed width string
    def __lengthener(self, string, desired_length) -> str:
        while len(string) < desired_length:
            string = f" {string}"
        return string

    def clock(self, bare=False) -> str:
        now = datetime.now()
        current_time = now.strftime("%H:%M")
        prefix = ""
        if bare:
            return current_time
        else:
            return f"{prefix} {current_time}"

    def workspaces(self):
        ws_cmd = subprocess.run(
            ["xprop", "-root", "_NET_CURRENT_DESKTOP"], capture_output=True, text=True
        )
        ws_current = int(ws_cmd.stdout.split()[2])

        ws_list_display = self.ws_list.copy()
        ws_list_display[ws_current] = ""
        return " ".join(ws_list_display)

    def battery(self):
        bat_cmd = subprocess.run(["acpi", "-b"], capture_output=True, text=True)
        level = int(bat_cmd.stdout.replace(",", "").split()[3].replace("%", ""))

        if level <= self.LOW:
            prefix = ""
        elif level <= self.MID:
            prefix = ""
        elif level < self.FULL:
            prefix = ""
        elif level >= self.FULL:
            prefix = ""
        else:
            prefix = ""

        return f"{prefix} {self.__lengthener(str(level), 3)}%%"

    def volume(self):
        vol_cmd = subprocess.run(
            ["pamixer", "--get-volume"], capture_output=True, text=True
        )
        level = int(vol_cmd.stdout)

        mute_cmd = subprocess.run(
            ["pamixer", "--get-mute"], capture_output=True, text=True
        )
        mute = mute_cmd.stdout.strip()

        if mute == "true":
            prefix = "M"
        elif level <= self.LOW:
            prefix = ""
        elif level <= self.MID:
            prefix = ""
        elif level > self.MID:
            prefix = ""
        else:
            prefix = ""

        return f"{prefix} {self.__lengthener(str(level), 3)}%%"

    def brightness(self):
        bri_cmd = subprocess.run(
            ["brightnessctl", "info", "-m"], capture_output=True, text=True
        )
        level = int(bri_cmd.stdout.split(",")[3].replace("%", ""))

        if level <= self.LOW:
            prefix = ""
        elif level <= self.MID:
            prefix = ""
        elif level > self.MID:
            prefix = ""
        else:
            prefix = ""

        return f"{prefix} {self.__lengthener(str(level), 3)}%%"

    def network(self):
        wifi_cmd = subprocess.run(
            ["iw", "dev"],
            capture_output=True,
            text=True,
        )
        wifi_match = re.search("(?<=ssid )(.*)", wifi_cmd.stdout)

        if not wifi_match:
            return " no wifi"
        else:
            return f" {wifi_match.group(0)}"

    # formatting constants
    LEFT = "%{l}"
    CENTER = "%{c}"
    RIGHT = "%{r}"
    SPACE = " "
    SEPARATOR = " | "
    ME = "longhouse>>"

    # returns generated bar script
    def __str__(self):
        bar_string_standard = [
            # left items
            self.LEFT,
            self.SPACE,
            self.ME,
            self.SPACE,
            self.workspaces(),
            # centered items
            self.CENTER,
            self.clock(bare=True),
            # right items
            self.RIGHT,
            self.network(),
            self.SEPARATOR,
            self.brightness(),
            self.SEPARATOR,
            self.volume(),
            self.SEPARATOR,
            self.battery(),
            self.SPACE,
        ]
        return "".join(bar_string_standard)


class LemonbarServer:
    PORT = 40674

    def __init__(self, string_gen: BarString):
        self.string_gen = string_gen
        self.socket = socket.socket()

    async def print_string(self, reader, writer):
        print(self.string_gen)
        sys.stdout.flush()
        # unused variables:
        del reader, writer

    async def print(self):
        while True:
            print(self.string_gen)
            sys.stdout.flush()
            await asyncio.sleep(1)

    async def respond(self):
        try:
            server = await asyncio.start_server(
                self.print_string, "localhost", self.PORT
            )
        except OSError:
            print("bar server already running somewhere!")
            exit()

        async with server:
            await server.serve_forever()

    async def run(self):
        respond = asyncio.create_task(self.respond())
        print = asyncio.create_task(self.print())

        await respond
        del print

    def send(self):
        self.socket.connect(("127.0.0.1", self.PORT))
        response = self.socket.recv(1024)
        self.socket.close()
        print(str(response))


def handle_args():
    parser = argparse.ArgumentParser(description="print lemonbar strings")
    parser.add_argument(
        "-u",
        "--update",
        help="instantaneously updates running instance of script",
        action="store_true",
    )
    args = parser.parse_args()
    return args


def main():
    args = handle_args()

    string_gen = BarString()
    server = LemonbarServer(string_gen)

    if args.update == True:
        server.send()
    else:
        try:
            asyncio.run(server.run())
        except KeyboardInterrupt:
            pass
        else:
            server.socket.close()


if __name__ == "__main__":
    main()
